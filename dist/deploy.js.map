{"version":3,"sources":["deploy.js"],"names":["Path","require","fs","Q","archiver","hdlUtil","fsUtil","Ssh2SftpClient","_defaultInitScript","join","Deploy","args","mandatoryFields","fd","getDeepVal","Error","leafFolderName","destFolderPath","initScript","resolve","author","promise","rsv","rst","regex2","RegExp","replace","regex","filePath","existsSync","unlink","err","console","error","folerPath","rej","rmdir","recursive","log","date2string","Date","folderPath","targetPath","promiseReturned","code","msg","lstatSync","isDirectory","output","createWriteStream","archive","zlib","level","on","pointer","sourcePath","pipe","bulk","expand","cwd","src","finalize","srcFolderPath","modifiedHours","servers","privateKeyPath","host","port","username","password","_this","recur","feed","tmpFolderPath","localBashFilePath","zipPath","length","qAll","push","removeFilePromise","removeFolderPromise","task","Object","assign","shift","preparedZipPath","preparedTmpFolderPath","exec2","then","params","lastSlashIdx","lastIndexOf","sep","slice","endsWith","zipFileName","parentFolderPath","destPathSep","indexOf","parentDestFolderPath","destFilePath","__dirname","sshClient2","sshOptions","rsvRoot","oType","copyFilteredFilesPromise","archiveFolderPromise","reject","readFile","privateKey","sshOptionsCopy","connect","put","end","done","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable arrow-parens */\n// import Path from 'path'\n// import fs from 'fs'\n// import Q from 'q';\n// // import zipFolder from 'zip-folder';\n// import archiver from 'archiver'\n// import _L from 'lodash';\n// import hdlUtil from './helpers/hdlUtil';\n// import fsUtil from './helpers/fsUtil';\n// import { NodeSSH } from 'node-ssh'\n\nconst Path = require('path');\nconst fs = require('fs');\n// const rimraf = require(\"rimraf\");\nconst Q = require('q');\nconst archiver = require('archiver');\n// const _L = require('lodash');\nconst hdlUtil = require('./helpers/hdlUtil');\nconst fsUtil = require('./helpers/fsUtil');\n// const { NodeSSH } = require('node-ssh');\n// https://www.npmjs.com/package/ssh2-sftp-client\nconst Ssh2SftpClient = require('ssh2-sftp-client');\n\nconst _defaultInitScript = [\n    '#!/bin/bash',\n    '# author: WangFan',\n    '# description: backup server directory',\n    'time1=$(date +\"%Y-%m-%dT%H-%M-%S\")',\n    \"str1='server.'\",\n    \"str2='.WangFan.backup.tar.gz'\",\n    'time2=$str1$time1$str2',\n    'tar -czvf $time2 server &&',\n    ' unzip server.zip &&',\n    ' nohup forever stop index.js &&',\n    ' rm -f server.zip &&',\n    ' forever start --minUptime 1000 --spinSleepTime 10000 -o nohup.out -e nohup.out index.js'\n    ].join('\\n');\n\nclass Deploy {\n    constructor (args = {}) {\n        const mandatoryFields = ['author', 'srcFolderPath']; // 'destFolderPath', 'host', 'username'\n        // const mandatoryOneFields = ['privateKeyPath', 'password']\n        // const optionalFields = ['initScript', modifiedHours];\n        for(let fd of mandatoryFields){\n            if(!hdlUtil.getDeepVal(args, fd)){\n                throw new Error(`mandatory field \"${fd}\" is missing`);\n            }\n        }\n        /* let isMandatoryOneOk = false; // 二选一\n        for(let fd of mandatoryOneFields){\n            if(hdlUtil.getDeepVal(args, fd)){\n                isMandatoryOneOk = true;\n                break;\n            }\n        }\n        if(!isMandatoryOneOk){\n            throw new Error(`mandatory field \"privateKeyPath / password\" is missing`);\n        } */\n        this.args = args;\n    }\n\n    getInitScriptPromise ({leafFolderName, destFolderPath}) {\n        if ( this.args.initScript ) {\n            return Q.resolve(this.args.initScript);\n        }\n        // const destFolderPath = this.args.destFolderPath;\n        const author = this.args.author;\n        return Q.promise((rsv/* , rej */) => {\n            /* const bashFilePath = Path.resolve(__dirname, 'helpers/backupServer.sh');\n            fs.readFile(bashFilePath, 'utf8', (err, rst) => {\n                if (err) {\n                    return rej(err);\n                } */\n                let rst = _defaultInitScript;\n                if(author){\n                    const regex2 = new RegExp('改前');\n                    rst = rst.replace(regex2, `.${author}.backup`);\n                }\n                rst = rst.replace(/\\$\\{destFolderPath\\}/g, destFolderPath);\n                if(!leafFolderName || leafFolderName === 'server'){\n                    return rsv(rst);\n                }else{\n                    const regex = new RegExp('server', 'g');\n                    rst = rst.replace(regex, leafFolderName);\n                    rsv(rst);\n                }\n            // })\n        })\n    }\n\n    removeFilePromise (filePath) {\n        return Q.promise((rsv/* , rej */) => {\n            // eslint-disable-next-line no-sync\n            if (!fs.existsSync(filePath)) {\n                return rsv(`removeFilePromise #111 not found: ${filePath}`);\n            }\n            fs.unlink(filePath, function (err) {\n                if (err) {\n                    console.error('removefilePromise #27', err);\n                }\n                rsv(filePath);\n            });\n        })\n    }\n\n    // rimraf(\"/some/directory\", function () { console.log(\"done\"); });\n    removeFolderPromise (folerPath) {\n        return Q.promise((rsv, rej) => {\n            // delete directory recursively\n            fs.rmdir(folerPath, { recursive: true }, (err) => {\n                if (err) {\n                    console.error(`fail to delete ${folerPath}, ERROR:`, err);\n                    rej(err);\n                }else{\n                    console.log(hdlUtil.date2string(new Date(), 'ms'), `#268 ${folerPath} is deleted!`);\n                    rsv(null);\n                }\n            });\n        })\n    }\n    \n    /** \n     * @param {String} folderPath the path of folder to be zipped\n     * @param {String} options options.deleteFolder Y 压缩后删除文件 \n     * @returns {String} zipPath\n     * */\n    // zipFolderHandler (folderPath, options = {}) {\n    //     if (_L.endsWith(folderPath, Path.sep)) {\n    //         folderPath = folderPath.slice(0, folderPath.length - 1);\n    //     }\n    //     const zipPath = _L.trim(hdlUtil.getDeepVal(options, 'zipPath') || `${folderPath}.zip`);\n    //     return Q.promise(function (rsv, rej) {\n    //         // eslint-disable-next-line no-sync\n    //         if (!fs.existsSync(folderPath)) {\n    //             return rsv({ code: 113 });\n    //         }\n    //         zipFolder(folderPath, zipPath, err => {\n    //             if (err) {\n    //                 rej(err)\n    //             } else {\n    //                 rsv({ code: 111, zipPath });\n    //             }\n    //         });\n    //     });\n    // }\n\n    /**\n     * 压缩文件夹\n     */\n    archiveFolderPromise(folderPath, targetPath){\n        return Q.promise((rsv, rej) => {\n            let promiseReturned = false;\n            if(!fs.existsSync(folderPath)){\n                return rej({code: 110, msg: `folderPath not exists: ${folderPath}`});\n            }\n            /*\n                stats.isFile()\n                stats.isDirectory()\n                stats.isBlockDevice()\n                stats.isCharacterDevice()\n                stats.isSymbolicLink() (only valid with fs.lstat())\n                stats.isFIFO()\n                stats.isSocket()\n            */\n            if(!fs.lstatSync(folderPath).isDirectory()){\n                return rej({code: 110, msg: `folderPath is not of folder: ${folderPath}`});\n            }\n            if(!targetPath){\n                targetPath = `${folderPath}.zip`; // Zip 文件不带.开头\n            }\n            \n            // create a file to stream archive data to.\n            const output = fs.createWriteStream(targetPath);\n            const archive = archiver('zip', {\n                zlib: { level: 9 } // Sets the compression level.\n            });\n\n            // listen for all archive data to be written\n            // 'close' event is fired only when a file descriptor is involved\n            output.on('close', function() {\n                console.log(archive.pointer() + ' total bytes');\n                console.log('archiver has been finalized and the output file descriptor has closed.');\n                if(promiseReturned){\n                    return;\n                }\n                promiseReturned = true;\n                rsv({sourcePath: folderPath, targetPath});\n            });\n\n            output.on('end', function() {\n                console.log('Data has been drained');\n                // if(promiseReturned){\n                //     return;\n                // }\n                // promiseReturned = true;\n                // rsv({sourcePath: folderPath, targetPath});\n            });\n\n            // good practice to catch this error explicitly\n            archive.on('error', function(err) {\n                // throw err;\n                if(promiseReturned){\n                    return;\n                }\n                promiseReturned = true;\n                rej(err);\n            });\n\n            // pipe archive data to the file\n            archive.pipe(output);\n\n            archive.bulk([\n                { expand: true, cwd: folderPath, src: ['**/*'] }\n            ]).finalize();\n\n            archive.finalize();\n        })\n    }\n\n    exec () {\n        const { srcFolderPath, modifiedHours } = this.args;\n        let servers = this.args.servers;\n        if(!servers){\n            const {destFolderPath, privateKeyPath, host, port, username, password} = this.args;\n            servers = [{destFolderPath, privateKeyPath, host, port, username, password}];\n        }\n        const _this = this;\n        const recur = (feed = {}) => {\n            const {tmpFolderPath, localBashFilePath, zipPath} = feed;\n            if(servers.length < 1){\n                const qAll = [];\n                qAll.push( this.removeFilePromise(zipPath) );\n                qAll.push( this.removeFilePromise(localBashFilePath) );\n                qAll.push( this.removeFolderPromise(tmpFolderPath) );\n                return;\n            }\n            const task = Object.assign({}, servers.shift(), {srcFolderPath, modifiedHours});\n            if(zipPath){\n                task.preparedZipPath = zipPath;\n                task.preparedTmpFolderPath = tmpFolderPath;\n            }\n            _this.exec2(task).then(recur);\n        }\n        recur();\n    }\n\n    exec2 (params = {}) {\n        const { srcFolderPath, modifiedHours, destFolderPath, privateKeyPath, host, port = 22, username, password } = params;\n        const preparedZipPath = params.preparedZipPath; // 同一批部署，不重复制作压缩包\n        const preparedTmpFolderPath = params.preparedTmpFolderPath; // 同一批部署，不重复制作压缩包\n        let tmpFolderPath; // if modifiedHours, copy selected files to ${tmpFolderPath} first\n        let lastSlashIdx = srcFolderPath.lastIndexOf(Path.sep);\n        if (lastSlashIdx === srcFolderPath.length - 1) {\n            lastSlashIdx = srcFolderPath.slice(0, -1).lastIndexOf(Path.sep);\n        }\n\n        let leafFolderName = srcFolderPath.slice(lastSlashIdx + 1);\n        if(hdlUtil.endsWith(leafFolderName, Path.sep)){\n            leafFolderName = leafFolderName.slice(0, leafFolderName.length - 1);\n        }\n        const zipFileName = `${leafFolderName}.zip`;\n\n        const parentFolderPath = srcFolderPath.slice(0, lastSlashIdx);\n        const zipPath = Path.resolve(parentFolderPath, zipFileName);\n\n        let destPathSep;\n        if(destFolderPath.indexOf('/') !== 0 || destFolderPath.slice(0, 4).indexOf(':') > 0){\n            destPathSep = '\\\\';\n        }else{\n            destPathSep = '/';\n        }\n        lastSlashIdx = destFolderPath.lastIndexOf(destPathSep);\n        if (lastSlashIdx === destFolderPath.length - 1) {\n            lastSlashIdx = destFolderPath.slice(0, -1).lastIndexOf(destPathSep);\n        }\n        const parentDestFolderPath = destFolderPath.slice(0, lastSlashIdx);\n        const destFilePath = `${parentDestFolderPath}${destPathSep}${zipFileName}`; // Path.resolve(parentDestFolderPath, zipFileName);\n        const localBashFilePath = Path.resolve(__dirname, '.backupServer.sh');\n        // const remoteBashFilePath = `${parentDestFolderPath}${destPathSep}backupServer.sh`;\n        let /* sshClient1, */ sshClient2; /* isBackupScriptExist */ /* , toPrint */\n        const sshOptions = {};\n        return Q.promise((rsvRoot/* , rejRoot */) => {\n            (() => {\n                // eslint-disable-next-line no-sync\n                if(fs.existsSync(zipPath) && !preparedZipPath){ // 不删除同一批任务留下的压缩包\n                    console.log('#284 remove file:', zipPath);\n                    return this.removeFilePromise (zipPath);\n                }else{\n                    return Q.resolve(null);\n                }\n            })().then(() => {\n                if(hdlUtil.oType(modifiedHours) === 'number'){\n                    if(preparedZipPath && fs.existsSync(zipPath)){ // 不重复制作压缩包\n                        return preparedTmpFolderPath;\n                    }\n                    return fsUtil.copyFilteredFilesPromise(srcFolderPath, modifiedHours);\n                }else{\n                    return;\n                }\n            }).then(feed => {\n                tmpFolderPath = feed;\n                if(fs.existsSync(zipPath) && preparedZipPath){ // 不重复制作压缩包\n                    return;\n                }\n                console.log('archive #305 path:', tmpFolderPath, srcFolderPath+'.zip');\n                return this.archiveFolderPromise(tmpFolderPath, srcFolderPath+'.zip');\n            }).then(() => {\n                if(!privateKeyPath || !fs.existsSync(privateKeyPath)){\n                    if(password){\n                        return null;\n                    }else{\n                        return Q.reject({code: 110, msg: 'no password'});\n                    }\n                }\n                return Q.promise((rsv, rej) => {\n                    fs.readFile(privateKeyPath, 'utf8', (err, rst) => {\n                        if (err) {\n                            return rej(err);\n                        }\n                        rsv(rst);\n                    })\n                })\n            }).then(( feed ) => {\n                // sshClient1 = new NodeSSH();\n                sshClient2 = new Ssh2SftpClient();\n                sshOptions.host = host;\n                sshOptions.port = port;\n                sshOptions.username = username;\n                if(feed){\n                    sshOptions.privateKey = feed;\n                }else{\n                    sshOptions.password = password;\n                }\n                const sshOptionsCopy = { ...sshOptions };\n                delete sshOptionsCopy.privateKey;\n                console.log('#339 connect:', sshOptionsCopy)\n                /* return sshClient1.connect(sshOptions)\n            }).then(() => {\n                const deferred = Q.defer();\n                setTimeout(function () {\n                    deferred.resolve()\n                }, 1500);\n                return deferred.promise;\n            }).then(() => { */\n                return sshClient2.connect(sshOptions)\n            }).then(() => {\n                console.log('#358', zipPath, '->', destFilePath)\n                return sshClient2.put(zipPath, destFilePath);\n            })/*.then(() => {\n                return this.getInitScriptPromise({leafFolderName, destFolderPath});\n            }).then(feed => {\n                return Q.promise((rsv, rej) => {\n                    const strBuf = Buffer.from(feed, 'utf-8');\n                    sshClient2.put(strBuf, remoteBashFilePath).then(function () {\n                        rsv({ destFilePath, msg: 'OK' });\n                    }, function (error) {\n                        rej(error);\n                    })\n                });\n            }) .then(() => {\n                return sshClient1.execCommand('chmod +x backupServer.sh', { cwd: parentDestFolderPath });\n            }).then(() => {\n                return sshClient1.execCommand('./backupServer.sh', { cwd: parentDestFolderPath });\n            }) */.then(() => {\n                // sshClient1.dispose();\n                sshClient2.end();\n                rsvRoot({code: 111, msg: 'OK', tmpFolderPath, localBashFilePath, zipPath});\n            }).done(null, err => {\n                if (!err) {\n                    return;\n                }\n                console.error('#75', err);\n                rsvRoot({code: 110, msg: 'ERROR'});\n            })\n        })\n    }\n\n}\nmodule.exports = Deploy;"],"file":"deploy.js"}